# 实验 2：32 位 ALU 设计与仿真

（这份报告就是按照自己做实验时的思路随手整理的，语言比较口语化一点。）

## 1. 实验目标
实现一个 32 位组合逻辑 ALU，支持实验指导给出的 11 条操作：

- 算术：ADD / ADDU / SUB / SUBU（用超前进位加法器）
- 移位：SLL / SRL / SRA（移位位数取 A[4:0]）
- 逻辑：AND / OR / XOR / NOR

并在 Vivado 中用给定的 `alu_tb.v` 做功能仿真，`correct` 信号应始终为 1。

## 2. 接口与编码
模块接口：`module alu(A,B,Op,C,Over);`

| 信号    | 方向   | 说明                                  |
| ------- | ------ | ------------------------------------- |
| A[31:0] | Input  | 第一个操作数（移位时下 5 位为位移量） |
| B[31:0] | Input  | 第二个操作数                          |
| Op[5:0] | Input  | 操作码                                |
| C[31:0] | Output | 结果                                  |
| Over    | Output | 溢出（仅对 ADD/SUB 有符号版本有效）   |

操作码直接与指导文档一致，没有做额外封装。

## 3. 设计思路
1. 提前把加法和减法都算好：
	- 加法：直接 `adder`（来自上一次实验的 32 位 CLA）。
	- 减法：A + (~B + 1)。
2. 有符号溢出判定：
	- ADD：被加数符号相同，结果符号不同。
	- SUB：A 与 B 符号不同，结果符号与 A 不同。
3. 无符号版本 Over 恒 0。
4. 移位：用 Verilog 自带移位操作符，算术右移用 `$signed(B) >>> shamt`。
5. 逻辑运算很直接：与/或/异或/或非。
6. 纯组合：整个 always 块用 `always @*`，没有时钟，也避免遗漏敏感列表导致综合 latch。

## 4. 关键代码片段说明
加/减结果预先算：
```
adder u_add (.a(A), .b(B),  .cin(1'b0), .sum(add_sum), .overflow(add_of));
adder u_sub (.a(A), .b(~B), .cin(1'b1), .sum(sub_sum), .overflow(sub_dummy_of));
```
溢出：
```
add_overflow_signed = (A[31] == B[31]) && (add_sum[31] != A[31]);
sub_overflow_signed = (A[31] != B[31]) && (sub_sum[31] != A[31]);
```
移位位数：`shamt = A[4:0]`。

## 5. 与测试激励的对应
测试文件里每个操作都跑了大量组合：
* ADD / SUB 前两段循环里也在自己算 `ans` 与 `cov`（其实就是溢出公式）。
* 无符号版本把 `cov` 强行置 0。
* 移位只取 A 的低 5 位，这里和实现保持一致。
* 逻辑运算都是中小范围移位后取不同位宽的拼出来的数，没有额外坑。

因此实现里保持：
* 不去偷懒用 `assign {Over,C} = ...`，而是显式分开，避免把溢出和进位混淆。
* SUB 也不用 adder 自带 overflow（因为减法那边输入已经变形），重新写判定更直观。

## 6. 仿真现象（口述）
跑完以后：
* 时间跨度大概两千多 ns（循环很多）。
* `correct` 在波形里始终为 1（用 “Find Value” 搜 0 没搜到）。
* ADD / SUB 时可以看到 Over 在边界用例（例如 0x7fffffff + 1，0x80000000 - 1 等）闪一下。
* SRA 对于负数（最高位 1）右移时高位补 1，与 `$signed` 语义吻合。

（截图略——实际提交时可把关键几组波形粘进来：ADD 溢出、SRA 右移、NOR 输出全 1 等。）

## 7. 可能的改进（这次没做）
* 可以把加/减复用成一套，加个选择信号，少一份 adder 实例，面积略减。
* 再往后扩展的话，可以加 SLT / SLTU / 乘法 / 逻辑左/右旋 / 位清除等。
* Overflow 也可以统一用一个小函数封装，代码更紧凑，不过现在已经比较清楚。

## 8. 小结
这次重点其实不在 ALU 本身，而是熟悉多文件 + 组合逻辑写法。结构上保持简单，不引入无关 feature，优先保证和测试激励一一对应。仿真通过后基本就 OK 了。

---
附：完整源码见 `alu.v`。

