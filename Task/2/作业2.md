1. 用 JK 触发器设计一个检测输入序列 0100 的同步时序电路，输入数码可以重复使用。例如，串行输入 00100100，依次输出 00001001。
2. 用 D 触发器设计一个同步六进制计数器，计数序列如下：

   000 → 001 → 010 → 011 → 100 → 101 → 000 （循环）

---

## 题一：序列 0100 同步可重叠检测电路（JK 触发器）

### 状态定义与编码

为方便最少触发器（2 个 JK），用“已匹配前缀长度”思想：

| 状态 | 含义         | 已匹配前缀 | 编码(Q1 Q0) |
| ---- | ------------ | ---------- | ----------- |
| S0   | 无有效前缀   | (空)       | 00          |
| S1   | 已匹配 "0"   | 0          | 01          |
| S2   | 已匹配 "01"  | 01         | 10          |
| S3   | 已匹配 "010" | 010        | 11          |

说明：最终匹配要看到 "010" 后再来一个 0。匹配完成当拍给脉冲，同时因为末尾是 0，可作为新前缀“0”继续（即回 S1）。

### 状态转移文字描述

节点 S0~S3

边标注 X/Z

| 现态   | X=0 → 次态 / Z | X=1 → 次态 / Z | 说明                                          |
| ------ | --------------- | --------------- | --------------------------------------------- |
| S0(00) | S1 /0           | S0 /0           | 刚看到 0 建立前缀；1 仍空                     |
| S1(01) | S1 /0           | S2 /0           | 0 继续作为新起点；1 得到 01                   |
| S2(10) | S3 /0           | S0 /0           | 0 得到 010；1 断裂回空                        |
| S3(11) | S1 /1           | S2 /0           | 0 完整 0100 输出1，末尾0作新前缀；1 则后缀=01 |

输出特征：只有 (状态=S3 且 X=0) 这一拍输出 1。

### 状态/输出表（列出全部 8 组合）

Q1Q0 为现态，X 输入。

| Q1 Q0 | X | Q1' Q0' | Z | 说明                         |
| ----- | - | ------- | - | ---------------------------- |
| 0 0   | 0 | 0 1     | 0 | S0 +0 -> S1                  |
| 0 0   | 1 | 0 0     | 0 | 留在 S0                      |
| 0 1   | 0 | 0 1     | 0 | S1 遇 0 仍 S1                |
| 0 1   | 1 | 1 0     | 0 | S1 遇 1 -> S2                |
| 1 0   | 0 | 1 1     | 0 | S2 遇 0 -> S3                |
| 1 0   | 1 | 0 0     | 0 | S2 遇 1 -> S0                |
| 1 1   | 0 | 0 1     | 1 | S3 遇 0 匹配完成 -> S1 输出1 |
| 1 1   | 1 | 1 0     | 0 | S3 遇 1 -> S2                |

### JK 激励表

JK 激励规则：
0→0: J=0,K=–；0→1: J=1,K=–；1→0: J=–,K=1；1→1: J=–,K=0。

| Q1 Q0 | X | Q1' Q0' | J1 | K1 | J0 | K0 |
| ----- | - | ------- | -- | -- | -- | -- |
| 0 0   | 0 | 0 1     | 0  | – | 1  | – |
| 0 0   | 1 | 0 0     | 0  | – | 0  | – |
| 0 1   | 0 | 0 1     | 0  | – | – | 0  |
| 0 1   | 1 | 1 0     | 1  | – | – | 1  |
| 1 0   | 0 | 1 1     | – | 0  | 1  | – |
| 1 0   | 1 | 0 0     | – | 1  | 0  | – |
| 1 1   | 0 | 0 1     | – | 1  | – | 0  |
| 1 1   | 1 | 1 0     | – | 0  | – | 1  |

“–” 为无关项（可被化简吸收）。

### 化简

观察 J0：为 1 的行： (Q1Q0X) = (001, 100)。写出最小项：Q1'Q0'X' + Q1Q0'X。再看能否合并：共同特征 Q0'=1 且 X 与 Q1 不同，直接更简练方式：J0 = ~X & ~Q0（这与表中第1行匹配；第5行 X=0 Q0=0 也满足）。验证：当 ~X & ~Q0 为 1 时确实需要置位 Q0（原 Q0=0）。符合表格出现的两处。

K0：为 1 的行： (0 1 1→0), (1 1 1→0), (1 0 1→0) 中 Q0 1→0 条件是 X=1 且 Q0=1。不论 Q1。故 K0 = X · Q0。

J1：为 1 的行： (0 1 1)，即 Q1=0,Q0=1,X=1 → J1 = ~Q1·Q0·X。

K1：为 1 的行： (1 0 1→0), (1 1 0→0)。对应：

- 行 (Q1,Q0,X)=(1,0,1) 即 Q1·Q0'·X
- 行 (1,1,0) 即 Q1·Q0·X'
  合并形式：K1 = Q1 (Q0'X + Q0X') = Q1 (Q0 ⊕ X)。

输出：Z=1 仅状态 Q1Q0=11 且 X=0 → Z = Q1·Q0·X'。

### 逻辑方程归纳（统一符号：~ 取反，· 省略，+ 或）

J0 = ~X · ~Q0
K0 = X · Q0
J1 = ~Q1 · Q0 · X
K1 = Q1 (Q0 ⊕ X)
Z  = Q1 · Q0 · ~X

### 工作过程示例（给定输入 00100100）

逐拍（忽略 rst 已释放）：

| 拍序 | X | 状态(Q1Q0) | 输出Z | 说明                        |
| ---- | - | ---------- | ----- | --------------------------- |
| 1    | 0 | 01         | 0     | 进入前缀 0                  |
| 2    | 0 | 01         | 0     | 冗余 0 保持                 |
| 3    | 1 | 10         | 0     | 得到 01                     |
| 4    | 0 | 11         | 0     | 得到 010                    |
| 5    | 0 | 01         | 1     | 完成 0100，输出并回 S1      |
| 6    | 1 | 10         | 0     | 01 +1 -> 01x=010? 此处成 01 |
| 7    | 0 | 11         | 0     | 再次到 010                  |
| 8    | 0 | 01         | 1     | 再次匹配输出                |

### Verilog 参考（行为等价 JK）

```verilog
module seq_0100_detector(
	input  wire clk,
	input  wire rst,   // 同步高有效复位
	input  wire X,
	output wire Z
);
	reg Q1, Q0;

	wire J0 = ~X & ~Q0;
	wire K0 =  X &  Q0;
	wire J1 = ~Q1 & Q0 & X;
	wire K1 =  Q1 & (Q0 ^ X);

	wire Q0_next = (J0 & ~Q0) | (~K0 & Q0);
	wire Q1_next = (J1 & ~Q1) | (~K1 & Q1);

	always @(posedge clk) begin
		if (rst) begin
			Q1 <= 1'b0; Q0 <= 1'b0;
		end else begin
			Q1 <= Q1_next;
			Q0 <= Q0_next;
		end
	end

	assign Z = Q1 & Q0 & ~X; // 匹配完成脉冲
endmodule
```

简单 testbench（只做功能例子）：

```verilog
module tb_seq_0100;
	reg clk=0, rst=1, X=0;
	wire Z;
	seq_0100_detector dut(clk,rst,X,Z);
	always #5 clk = ~clk;
	reg [7:0] vec = 8'b00100100; // 从高到低依次输入
	integer i;
	initial begin
		#12 rst=0;
		for (i=7;i>=0;i=i-1) begin
			@(negedge clk); X = vec[i];
		end
		#40 $finish;
	end
endmodule
```

## 题二：同步六进制计数器（D 触发器）

### 状态 / 次态表

| 现态 Q2Q1Q0 | 十进制 | 次态 Q2'Q1'Q0' |
| ----------- | ------ | -------------- |
| 000         | 0      | 001            |
| 001         | 1      | 010            |
| 010         | 2      | 011            |
| 011         | 3      | 100            |
| 100         | 4      | 101            |
| 101         | 5      | 000            |
| 110         | X      | 000 (自恢复)   |
| 111         | X      | 000 (自恢复)   |

### D 输入推导

分别写出每位的下一状态：
Q0 序列：0,1,0,1,0,1,0 → 每拍翻转 ⇒ D0 = ~Q0。

Q1：状态序列(对应 Q2Q1Q0)：
000→001 (Q1=0→0)
001→010 (0→1)
010→011 (1→1)
011→100 (1→0)
100→101 (0→0)
101→000 (0→0)
观察为 0→1 只发生在从 001 到 010（即 Q2=0,Q1=0,Q0=1），保持 1 仅在 010/011 之间。化简结果与常规模6设计一致：D1 = ~Q2 & (Q0 ^ Q1)。

Q2：变为 1 的情况：011→100，保持 1：100→101，然后回 0。可写：
Q2' = (Q1 & Q0) + (Q2 & ~Q1 & ~Q0)。

非法状态 110/111：强制下一拍 000，可在组合层加一个复用：illegal = Q2 & Q1，若为 1 则 D2,D1,D0=0。

### 逻辑方程（~取反，&，|，^）

D0 = ~Q0
D1 = ~Q2 & (Q0 ^ Q1)
D2 = (Q1 & Q0) | (Q2 & ~Q1 & ~Q0)
illegal = Q2 & Q1
若自恢复：Dk_safe = illegal ? 1'b0 : Dk。

### Verilog 参考实现

```verilog
module mod6_counter(
	input  wire clk,
	input  wire rst,      // 同步高有效复位
	output reg  Q2,
	output reg  Q1,
	output reg  Q0
);
	wire D0 = ~Q0;
	wire D1 = ~Q2 & (Q0 ^ Q1);
	wire D2 = (Q1 & Q0) | (Q2 & ~Q1 & ~Q0);
	wire illegal = Q2 & Q1; // 110 或 111

	wire next_Q0 = illegal ? 1'b0 : D0;
	wire next_Q1 = illegal ? 1'b0 : D1;
	wire next_Q2 = illegal ? 1'b0 : D2;

	always @(posedge clk) begin
		if (rst) begin
			Q2 <= 1'b0; Q1 <= 1'b0; Q0 <= 1'b0;
		end else begin
			Q2 <= next_Q2;
			Q1 <= next_Q1;
			Q0 <= next_Q0;
		end
	end
endmodule
```

简单 testbench：

```verilog
module tb_mod6;
	reg clk=0, rst=1;
	wire Q2,Q1,Q0;
	mod6_counter dut(clk,rst,Q2,Q1,Q0);
	always #5 clk = ~clk;
	integer k;
	initial begin
		#15 rst=0;
		for (k=0;k<20;k=k+1) @(negedge clk);
		$finish;
	end
endmodule
```
