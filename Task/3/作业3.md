2.23  [5] <2.7> 假设 $t0 中存放数值 0x00101000，在执行下列指令后 $t2 的值是多少？

```
    slt $t2, $0, $t0
    bne $t2, $0, ELSE
    j DONE
    ELSE: addi $t2, $t2, 2
    DONE:
```

2.24  [5] <2.7> 假设程序计数器（PC）被设置为 0x2000 0000，是否可以使用 MIPS 的跳转（j）指令将 PC 设置为地址 0x4000 0000？是否可以使用 MIPS 的相等则分支（beq）指令将 PC 设置为该地址？

---

## 解题思路与答案

### 2.23

已知：$t0 = 0x0010_1000（为正数）。逐条看：

1) `slt $t2, $0, $t0`
- 有符号比较，判断 0 < $t0 是否成立。由于 $t0 为正，条件成立，故 `$t2 ← 1`。

2) `bne $t2, $0, ELSE`
- 此时 $t2 = 1，与 0 不相等，分支成立，跳到 `ELSE`，因此后面的 `j DONE` 不会执行。

3) 在 `ELSE` 标签执行 `addi $t2, $t2, 2`
- `$t2 ← 1 + 2 = 3`。

4) 之后顺序流到 `DONE` 结束。

结论：$t2 = 3。

### 2.24

先回忆两条指令的目标地址形成方式：

- 跳转 `j target`：目标地址由
    高 4 位取自 `PC+4` 的高 4 位，拼接 26 位立即数左移 2 位而成。
    也就是：`{ (PC+4)[31:28], target[25:0], 2'b00 }`

- 分支 `beq rs, rt, offset`：目标地址为
    `PC' = PC + 4 + sign_extend(offset) << 2`
    其中 `offset` 为 16 位有符号数，范围约为 ±2^15 条指令，即跳转范围约为 ±128KB。

本题 `PC = 0x2000_0000`：

- 对 `j`：高 4 位会被固定为 `(PC+4)[31:28] = 0x2`，因此跳转结果必在 `0x2xxx_xxxx` 区间；`0x4000_0000` 的高 4 位为 `0x4`，不可能由一条 `j` 从 `0x2000_0000` 直接到达。→ 不能。

- 对 `beq`：最大前向位移约为 `(+32767 << 2) = 0x1FFFC ≈ 128KB`，最大后向位移约为 `(-32768 << 2) = -0x20000`。从 `0x2000_0000` 到 `0x4000_0000` 距离远超 ±128KB，显然超出分支范围。→ 不能。

结论：`j` 不行，`beq` 也不行。
